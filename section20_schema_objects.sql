-- ADDING & MANAGING CONSTRAINTS

DROP TABLE EMP2;

CREATE TABLE EMP2
AS
  SELECT * FROM EMPLOYEES;

CREATE TABLE DEPT3
AS
  SELECT * FROM DEPARTMENTS;
  
-- ONLY NOT NULL CONSTRAINTS COPIED
DESC EMP2;

-----------------------------------------------
-- ADDING PRIMARY KEY
SELECT *
FROM EMP2;

ALTER TABLE EMP2
MODIFY EMPLOYEE_ID PRIMARY KEY;

-- CAN SEE THE ADDED CONSTRAINT, TYPE P
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP2';

-- REMOVE LAST ADDED CONSTRAINT
ALTER TABLE EMP2
DROP CONSTRAINT &CONS;

-- ADD WITH NAME
ALTER TABLE EMP2
ADD CONSTRAINT EMP2_PK PRIMARY KEY (EMPLOYEE_ID);

ALTER TABLE DEPT3
ADD CONSTRAINT DEPT3_PK PRIMARY KEY (DEPARTMENT_ID);

-----------------------------------------------
-- ADDING FOREIGN KEY
-- METHOD 1
ALTER TABLE EMP2
MODIFY DEPARTMENT_ID REFERENCES DEPT3 (DEPARTMENT_ID);

-- METHOD 2
ALTER TABLE EMP2
ADD CONSTRAINT EMP_FK_DEPT FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPT3 (DEPARTMENT_ID);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP2';

-----------------------------------------------
-- ADDING NOT NULL CONSTRAINTS
-- ONLY POSSIBLE IF TABLE IS EMPTY OR SPECIFIED COLUMN HAS VALUE FOR ALL ROWS
ALTER TABLE EMP2
MODIFY FIRST_NAME NOT NULL;

DESC EMP2;

-- CANNOT DELETE MASTER RECORD BECAUSE THERE IS DEPENDENT TABLE
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP2', 'DEPT2')
AND CONSTRAINT_TYPE IN ('P', 'R')
ORDER BY TABLE_NAME;

ALTER TABLE DEPT3
DROP PRIMARY KEY; -- CANNOT DELETE DUE TO FOREIGN KEY

-- CAN CASCADE DROP IT
ALTER TABLE DEPT3
DROP PRIMARY KEY CASCADE;
-- BOTH PRIMARY AND FOREIGN KEY REMOVED
-----------------------------------------------

ALTER TABLE DEPT3
DROP COLUMN DEPARTMENT_ID;
-- CANNOT DROP BECAUSE IT IS A PARENT KEY COLUMN

-- CAN DROP USING CASCADED CONSTRAINTS
ALTER TABLE DEPT3
DROP COLUMN DEPARTMENT_ID CASCADE CONSTRAINTS;
-- BOTH CONSTRAINTS REMOVED

-----------------------------------------------
-- RENAME COLUMN AND CONSTRAINT
SELECT * FROM EMP2;

SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'EMP2';

ALTER TABLE EMP2
RENAME COLUMN FIRST_NAME TO FNAME;

SELECT * FROM EMP2;

SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'EMP2';
-- CONSTRAINT REFERENCES THE NEW NAME FOR THE COLUMN AUTOMATICALLY

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP2', 'DEPT3')
AND CONSTRAINT_TYPE IN ('P', 'R')
ORDER BY TABLE_NAME;

-- CHANGE CONSTRAINT NAME
ALTER TABLE EMP2
RENAME CONSTRAINT EMP2_PK TO NEW_EMP2_PK;

-----------------------------------------------
-- ENABLE/DISABLE CONSTRAINTS
-- CONSTRAINTS ARE USUALLY DISABLED DURING DATA MIGRATION
DROP TABLE EMP2;

DROP TABLE DEPT2;

CREATE TABLE EMP2
AS SELECT * FROM EMPLOYEES;

CREATE TABLE DEPT2
AS SELECT * FROM DEPARTMENTS;

SELECT * FROM EMP2;

SELECT * FROM DEPT2;

ALTER TABLE DEPT2
ADD CONSTRAINT DEPT2_PK PRIMARY KEY (DEPARTMENT_ID);

ALTER TABLE EMP2
ADD CONSTRAINT EMP2_PK PRIMARY KEY (EMPLOYEE_ID);

ALTER TABLE EMP2
ADD CONSTRAINT EMP2_FK FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPT2 (DEPARTMENT_ID);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP2', 'DEPT2');

SELECT * FROM USER_INDEXES
WHERE TABLE_NAME = 'EMP2';

ALTER TABLE EMP2
DISABLE CONSTRAINT EMP2_PK;

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP2', 'DEPT2')
AND CONSTRAINT_TYPE IN ('P', 'R')
ORDER BY TABLE_NAME;

-- ORACLE DROPS THE UNIQUE INDEX, WHEN THE CONSTRAINT WAS DISABLED
SELECT * FROM USER_INDEXES
WHERE TABLE_NAME = 'EMP2';

ALTER TABLE EMP2
ENABLE CONSTRAINT EMP2_PK;
-- ORACLE CREATES THE UNIQUE INDEX AGAIN

ALTER TABLE DEPT2
DISABLE CONSTRAINT DEPT2_PK;
-- ERROR - cannot disable constraint (HR.DEPT2_PK) - dependencies exist
-- BECAUSE OF FOREIGN KEY

-- WORKS WITH CASCADE
ALTER TABLE DEPT2
DISABLE CONSTRAINT DEPT2_PK CASCADE;

-- BOTH PRIMARY AND FOREIGN KEY ARE DISABLED
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP2', 'DEPT2')
AND CONSTRAINT_TYPE IN ('P', 'R')
ORDER BY TABLE_NAME;

ALTER TABLE DEPT2
ENABLE CONSTRAINT DEPT2_PK;

-- BUT AFTER ENABLING IT, THE FOREIGN KEY IS STILL DISABLED(!)
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP2', 'DEPT2')
AND CONSTRAINT_TYPE IN ('P', 'R')
ORDER BY TABLE_NAME;
-- CANNOT ENABLE IT IN CASCADE

-----------------------------------------------
/*
DEFERRABLE CONSTRAINTS
WILL ONLY CHECK CONSTRAINTS ON COMMIT, INSTEAD OF DURING A COMMAND
TWO OPTIONS ARE - 
DEFERRABLE INITIALLY DEFERRED
DEFERRABLE INITIALLY IMMEDIATE
*/

DROP TABLE EMP_SAL;

CREATE TABLE EMP_SAL
( EMP_ID NUMBER,
  SAL NUMBER,
  BONUS NUMBER,
  CONSTRAINT SAL_CK CHECK (SAL > 100),
  CONSTRAINT BONUS_CK CHECK (BONUS > 0)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_SAL';
-- CONSTRAINTS FIRED IMMEDIATELY

-- ANY DML THAT DOES NOT MEET THE CONDITION, GETS AN IMMEDIATE ERROR
INSERT INTO EMP_SAL (EMP_ID, SAL, BONUS)
VALUES (1, 90, 5);

INSERT INTO EMP_SAL (EMP_ID, SAL, BONUS)
VALUES (1, 110, -2);

-- DROP CONSTRAINTS AND RECREATE
ALTER TABLE EMP_SAL
DROP CONSTRAINT SAL_CK;

ALTER TABLE EMP_SAL
DROP CONSTRAINT BONUS_CK;

ALTER TABLE EMP_SAL
ADD CONSTRAINT SAL_CK CHECK (SAL > 100) DEFERRABLE INITIALLY DEFERRED;

ALTER TABLE EMP_SAL
ADD CONSTRAINT BONUS_CK CHECK (BONUS > 0) DEFERRABLE INITIALLY IMMEDIATE;

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_SAL';

-- ONLY ERROR ON COMMIT
INSERT INTO EMP_SAL (EMP_ID, SAL, BONUS)
VALUES (1, 90, 5);

-- GIVES ERROR IMMEDIATELY
INSERT INTO EMP_SAL (EMP_ID, SAL, BONUS)
VALUES (1, 110, -2);

-- CHANGE TYPE OF DEFERRABLE
SET CONSTRAINT SAL_CK IMMEDIATE;

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_SAL';
-- STILL SHOWS DEFERRED BECAUSE THAT IS THE ORIGINAL
-- THE CHANGE IS ONLY IN THE SESSION

INSERT INTO EMP_SAL (EMP_ID, SAL, BONUS)
VALUES (1, 90, 5); -- NOW FIRES IMMEDIATELY

-- IF CONSTRAINT WAS CREATED IN A NORMAL WAY, WE CANNOT CHANGE THE CONSTRAINT
-- TO IMMEDIATE/DEFERRED

-----------------------------------------------
-- GLOBAL TEMPORARY TABLE
-- TEMPORARY TABLE CREATED FOR EXAMPLE DURING AN AMAZON.COM SESSION
-- EACH SESSION CAN SEE AND MODIFY ONLY ITS DATA

CREATE GLOBAL TEMPORARY TABLE CART
(ITEM_NO NUMBER, QTY NUMBER)
ON COMMIT DELETE ROWS;

INSERT INTO CART VALUES (1, 10);
INSERT INTO CART VALUES (2, 4);

SELECT * FROM CART;

COMMIT;

SELECT * FROM CART;
-- TABLE IS EMPTY AFTER COMMIT

-- OTHER OPTION IS 
CREATE GLOBAL TEMPORARY TABLE CART2
(ITEM_NO NUMBER, QTY NUMBER)
ON COMMIT PRESERVE ROWS;

-- EVEN ON COMMIT DATA IS PRESERVED, BUT ONLY FOR THIS SESSION

-----------------------------------------------
-- SQL*LOADER
-- BULK LOADER UTILITY FOR MOVING FILES FROM EXTERNAL FILES TO DATABASE

CREATE TABLE EMP_LOAD
( EMPNO NUMBER,
  FNAME VARCHAR2(100),
  LNAME VARCHAR2(100)
);

SELECT * FROM EMP_LOAD;

/*
To move data from 'E:\load\emp.csv' to table EMP_LOAD, use SQL*Loader
Need to create a control file (.ctl), and add these instructions to it

LOAD DATA
INFILE 'E:\load\emp.csv'
APPEND
INTO TABLE EMP_LOAD
FIELDS TERMINATED BY ','
( EMPNO,
  FNAME,
  LNAME
)

Then execute the command in cmd

sqlldr control=E:\load\emp.ctl log=E:\load\emp.log

More details will be available from the log

If some rows were not loaded, it is placed in the .BAD file
*/

/*
External tables are read-only tables whose metadata is stored in the DB, but 
whose data is stored outside the DB. 
No DML allowed, and no indexes can be created on external tables.
The data can be accessed using two methods - oracle_loader or oracle_datapump

To read external data, first need to create directory in the DB

For this need Create any directory privilege, then conn to sqlplus sys as sysdba

alter session set container=orclpdb;
grant create any directory to hr;
*/

CREATE OR REPLACE DIRECTORY EMP_DIR
AS 'E:\EXTERNAL';

SELECT * FROM ALL_DIRECTORIES
WHERE DIRECTORY_NAME = 'EMP_DIR';
-- DIRECTORY OWNER IS ALWAYS SYS

CREATE TABLE EMP_LOAD_EXT
  ( EMPLOYEE_NUMBER NUMBER,
    FNAME VARCHAR2(100),
    LNAME VARCHAR2(100)
  )
  ORGANIZATION EXTERNAL
  ( TYPE ORACLE_LOADER
    DEFAULT DIRECTORY EMP_DIR
    ACCESS PARAMETERS
    ( RECORDS DELIMITED BY NEWLINE
      FIELDS TERMINATED BY ','
    )
    LOCATION ('OLD_EMP_DATA.CSV')
  )
  REJECT LIMIT UNLIMITED;
  -- EVEN IF LARGE NUMBER OF ERRORS, LOAD THE TABLE
  
SELECT * FROM EMP_LOAD_EXT;

DELETE EMP_LOAD_EXT; -- OPERATION NOT SUPPORTED ON EXTERNAM ORGANIZED TABLES

-----------------------------------------------

-- USING ORACLE DATAPUMP

CREATE TABLE EMP_PUMP
  ( EMPLOYEE_NUMBER,
    FNAME,
    LNAME
  )
  ORGANIZATION EXTERNAL
  ( TYPE ORACLE_DATAPUMP
    DEFAULT DIRECTORY EMP_DIR
    LOCATION ('EMP.DMP')
  )
  AS
  SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME
  FROM EMPLOYEES;
  
SELECT * FROM EMP_PUMP;

-- 2ND SYNTAX - FOR READING A DUMP FILE
CREATE TABLE EMP_PUMP_READ
  ( EMPLOYEE_NUMBER NUMBER,
    FNAME VARCHAR2(100),
    LNAME VARCHAR2(100)
  )
  ORGANIZATION EXTERNAL
  ( TYPE ORACLE_DATAPUMP
    DEFAULT DIRECTORY EMP_DIR
    LOCATION ('EMP.DMP')
  );
  
-- DML OPERATIONS ARE NOT ALLOWED ON EXTERNAL TABLES - INSERT, UPDATE, DELETE