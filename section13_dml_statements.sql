-- DML STATEMENTS
DESC DEPARTMENTS;

SELECT * FROM DEPARTMENTS;

-- RECOMMENDED SYNTAX
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (71, 'Development 1', 100, 1700);
COMMIT;

-- EXPLICIT METHOD TO INSERT NULL VALUES
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (75, 'Development 5', NULL, NULL);
COMMIT;

INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
VALUES                (1, 'N', 'Suresh', 'nsu@gmail.com', SYSDATE, 'IT_PROG');
COMMIT;

-- INSERT WITH SUBQUERY
CREATE TABLE XX_EMP
(EMPNO NUMBER,
 FNAME VARCHAR2(100),
 SALARY NUMBER
);

SELECT * FROM XX_EMP;

INSERT INTO XX_EMP (EMPNO, FNAME, SALARY)
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES;

SELECT * FROM XX_EMP;


-- COMMON ERROR EXAMPLES
-- INSERTING EXISTING VALUE FOR PRIMARY KEY
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (10, 'Development 1', 100, 1700);

-- INSERTING FK VALUE WHICH DOES NOT EXIST IN REFERENCE TABLE
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (73, 'Development 1', 100, 1);

-- INSERTING MISMATCHING DATATYPE

-- INSERTING VALUES EXCEEDING LENGTH
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (73, 'Development AND STUDIES RESEARCH DEPARTMENT', 100, 1700);


-- UPDATE STATEMENT
-- SYNTAX
UPDATE XX_EMP
SET SALARY=24100
WHERE EMPNO=100;
COMMIT;

CREATE TABLE COPY_EMP
AS
SELECT * FROM EMPLOYEES;

SELECT *
FROM COPY_EMP;

UPDATE COPY_EMP
SET SALARY=24100, DEPARTMENT_ID=10
WHERE EMPLOYEE_ID=100;
COMMIT;

-- USING SUBQ IN UPDATE
UPDATE COPY_EMP
SET SALARY = (SELECT SALARY FROM COPY_EMP WHERE EMPLOYEE_ID=200)
WHERE EMPLOYEE_ID=100;
COMMIT;

UPDATE COPY_EMP
SET (SALARY, DEPARTMENT_ID) = (SELECT SALARY, DEPARTMENT_ID FROM COPY_EMP WHERE EMPLOYEE_ID=108)
WHERE EMPLOYEE_ID=105;

SELECT *
FROM COPY_EMP
WHERE EMPLOYEE_ID IN (105, 108);


-- DELETE STATEMENT
CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENTS;

SELECT * FROM DEPT_COPY;

-- ONLY NOT NULL CONDITION CARRIES OVER
DESC DEPT_COPY;

SELECT * FROM DEPT_COPY
WHERE DEPARTMENT_ID = 10;

-- FROM IS OPTIONAL
DELETE FROM DEPT_COPY
WHERE DEPARTMENT_ID = 10;
COMMIT;

--CAN ROLLBACK THE DELETE

-- DELETE BASED ON SUBQUERY
DELETE FROM DEPT_COPY
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPT_COPY WHERE DEPARTMENT_NAME LIKE '%Public%');

-- TRUNCATE REMOVES ROWS, NO ROLLBACK
-- TRUNCATE IS DDL STATEMENT
COMMIT;

-- COMMIT, ROLLBACK PRACTICE
SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID IN (200, 201);

SELECT * FROM DEPARTMENTS
WHERE DEPARTMENT_ID = 1;

UPDATE EMPLOYEES
SET SALARY = SALARY + 100
WHERE EMPLOYEE_ID = 200;

UPDATE EMPLOYEES
SET SALARY = SALARY + 50
WHERE EMPLOYEE_ID = 201;

INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (1, 'ADMINISTRATION 2', 200, 1700);

-- ALL ABOVE DML WILL BE COMMITED
COMMIT;

SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID IN (200, 201);

SELECT * FROM DEPARTMENTS
WHERE DEPARTMENT_ID = 1;

-- STATEMENT LEVEL ROLLBACK
SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID IN (106, 107);

DELETE FROM EMPLOYEES
WHERE EMPLOYEE_ID = 106;

-- ROLLBACK IS ONLY FOR THIS STATEMENT
DELETE FROM DEPARTMENTS;

DELETE FROM EMPLOYEES
WHERE EMPLOYEE_ID = 107;

-- ANY DCL OR DDL STATEMENTS LEADS TO AUTOCOMMIT

-- SAVEPOINTS
SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID = 108;

UPDATE EMPLOYEES
SET SALARY = SALARY + 10
WHERE EMPLOYEE_ID = 108;

SAVEPOINT A;

UPDATE EMPLOYEES
SET SALARY = SALARY + 20
WHERE EMPLOYEE_ID = 108;

ROLLBACK TO SAVEPOINT A;

COMMIT;

SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID = 108;

-- ROW LOCKS
SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID = 109;

UPDATE EMPLOYEES
SET SALARY = SALARY + 20
WHERE EMPLOYEE_ID = 109;

-- ANOTHER SESSION STILL SEES THE INITIAL VALUE, IF NO COMMIT DONE TILL THEN
-- ALSO THIS ROW WILL BE LOCKED
COMMIT;

-- FOR UPDATE
-- USED TO LOCK ROWS
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10
FOR UPDATE;

-- CAN REMOVE LOCKS BY COMMIT OR ROLLBACK
COMMIT;

SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10
FOR UPDATE WAIT 10;

COMMIT; 

-- IN JOIN, IT LOCKS ROWS OF ALL TABLES IN THE JOIN

-------------------------------------------------
-------------------------------------------------
-- PRACTICE

DESC DEPARTMENTS;

INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (79, 'Dept123', 100, 1700);
COMMIT;

INSERT INTO DEPARTMENTS
VALUES                  (124, 'Dept124', 100, 1700);
-- IF NOT USING COLUMN NAMES, ALL VALUES HAVE TO BE ENTERED, EVEN NULLABLE ONES
COMMIT;

-- EXPLICITLY ASSIGNING NULLS
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES                  (179, 'Dept179', NULL, NULL);
COMMIT;

-- USING SUBSTITUTION VARIABLES
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME)
VALUES                  (&DEPTID, &DEPTNAME);

SELECT *
FROM XX_EMP;

INSERT INTO XX_EMP (EMPNO, FNAME, SALARY)
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES;

-- COMMON INSERTION ERRORS
-- ADDING DUPLICATE PK - UNIQUE CONSTRAINT VIOLATED
-- FK - REFERENTIAL CONSTRAINT VIOLATED
-- WRONG DATATYPE
-- VALUE EXCEEDING COLUMN LENGTH

-------------------------------------------------
-- UPDATE
SELECT *
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 100;

UPDATE EMPLOYEES
SET SALARY = 24100
WHERE EMPLOYEE_ID = 100;
COMMIT;

-- UPDATING AND SELECTING COLUMNS USING NON-PRIMARY KEY IS NOT RECOMMENDED

SELECT *
FROM COPY_EMP;

UPDATE COPY_EMP
SET SALARY = 25000, DEPARTMENT_ID = 15
WHERE EMPLOYEE_ID = 100;
COMMIT;

-- CAN SET COLUMN TO NULL VALUE

SELECT *
FROM COPY_EMP
WHERE EMPLOYEE_ID IN (100, 200);

UPDATE COPY_EMP
SET SALARY = 10*(SELECT SALARY FROM COPY_EMP
WHERE EMPLOYEE_ID = 200)
WHERE EMPLOYEE_ID = 100;

COMMIT;

-- CAN UPDATE MULTIPLE COLUMNS
UPDATE COPY_EMP
SET (SALARY, DEPARTMENT_ID) = (SELECT SALARY, DEPARTMENT_ID FROM COPY_EMP
                               WHERE EMPLOYEE_ID = 108)
WHERE EMPLOYEE_ID = 105;

SELECT *
FROM COPY_EMP
WHERE EMPLOYEE_ID IN (105, 108);

COMMIT;

-------------------------------------------------
-- DELETE
-- FROM KEYWORD IS OPTIONAL
SELECT *
FROM DEPT_COPY
WHERE DEPARTMENT_ID = 71;

-- WHILE COPYING A TABLE, ONLY NOT NULL CONSTRAINT IS COPIED

DELETE DEPT_COPY
WHERE DEPARTMENT_ID = 71;
ROLLBACK;

-- CAN USE A SUBQUERY IN THE DELETE'S WHERE CLAUSE
SELECT DEPARTMENT_ID
FROM DEPT_COPY
WHERE DEPARTMENT_NAME LIKE '%Public%';

TRUNCATE TABLE DEPT_COPY; -- CANNOT ROLLBACK

-- DELETE IS A DML STATEMENT, WHILE TRUNCATE IS A DDL
-- DELETE DOES NOT RECOVER SPACE, BUT TRUNCATE RECOVERS SPACE

-- ROLLBACK ONLY REMOVES PENDING UNCOMMITTED TRANSACTIONS

SELECT * FROM DEPT_COPY;

UPDATE DEPT_COPY
SET MANAGER_ID = 202
WHERE DEPARTMENT_ID = 20;

UPDATE DEPT_COPY
SET MANAGER_ID = 250
WHERE DEPARTMENT_ID = 30;

COMMIT;
-- COMMITS ALL THE ABOVE DML STATEMENTS

-- ROLLBACKS AND COMMITS ARE NOT TABLE-DEPENDENT
-- ALL TABLES CHANGES ARE COMMITTED/ROLLED BACK

-- STEMENT LEVEL ROLLBACKS OCCUR WHEN ERROR OCCURS, AND ONLY AFFECTS THAT
-- PARTICULAR COMMAND

-- IF ANY DMLS DONE, AND DDL/DCL FOLLOWS IT, THE DMLS ARE AUTOMATICALLY COMMITTED
-- IMPLICIT COMMIT

-- IF GOING TO A PARTICULAR SAVEPOINT, ALL SAVEPOINTS AFTER THAT ARE REMOVED

-- IF THERE IS A LOCK ON A ROW, ANOTHER SESSION CANNOT MAKE UPDATES TO THAT ROW

-- TO SET A LOCK ON SOME RECORDS, USE THE 'FOR UPDATE' CLAUSE
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10
FOR UPDATE;

-- CAN RELEASE THE RECORD USING A COMMIT OR ROLLBACK
-- ADDITIONAL FUNCTIONALITY WITH NOWAIT AND WAIT [10] ETC.

-- CAN SPECIFY 'FOR UPDATE OF [COL]' TO LOCK ONLY THE TABLE THAT HAS THAT
-- COLUMN


