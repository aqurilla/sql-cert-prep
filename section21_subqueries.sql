-- RETRIEVING DATA USING SUBQUERIES

SELECT LOCATION_ID, CITY
FROM LOCATIONS;

SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM DEPARTMENTS;

-- USING INLINE VIEW
SELECT DEPT.DEPARTMENT_ID, DEPT.DEPARTMENT_NAME, LOC.CITY
FROM DEPARTMENTS DEPT, (SELECT LOCATION_ID, CITY FROM LOCATIONS) LOC
WHERE DEPT.LOCATION_ID = LOC.LOCATION_ID;

----------------------------------------------
-- PAIRWISE/NON-PAIRWISE SUBQUERIES
SELECT * 
FROM EMPLOYEES
WHERE FIRST_NAME = 'John';

-- PAIRWISE COMPARISON SUBQUERY (BOTH COLUMNS HAVE TO BE MATCHED)
SELECT * FROM EMPLOYEES
WHERE (MANAGER_ID, DEPARTMENT_ID) IN (SELECT MANAGER_ID, DEPARTMENT_ID
                                      FROM EMPLOYEES WHERE FIRST_NAME = 'John')
AND FIRST_NAME != 'John';

-- NONPAIRWISE COMPARISON SUBQUERY
SELECT * FROM EMPLOYEES
WHERE MANAGER_ID IN (SELECT MANAGER_ID FROM EMPLOYEES WHERE FIRST_NAME = 'John')
AND DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'John')
AND FIRST_NAME != 'John';

----------------------------------------------
-- SCALAR / CORRELATED SUBQUERY
-- SCALAR SUBQUERY RETURNS ONE COLUMN VALUE FROM ONE ROW

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY, (SELECT MAX(SALARY) FROM EMPLOYEES) MAX_SAL
FROM EMPLOYEES;

-- CORRELATED SUBQUERY - SUBQUERY REFERENCES A COLUMN IN THE PARENT QUERY
-- FOR EXAMPLE, TO ALSO DISPLAY THE DEPARTMENT NAME IN ABOVE QUERY
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID,
  NVL((SELECT DEPARTMENT_NAME FROM DEPARTMENTS B WHERE B.DEPARTMENT_ID = E.DEPARTMENT_ID), 'NO DEPT') DEPT_NAME
FROM EMPLOYEES E;
-- E.DEPARTMENT_ID IS REPLACED IN THE SUBQUERY AS A NUMBER FROM THE PARENT QUERY

-- FIND EMPLOYEES WHO EARN MORE THAN THE AVERAGE SALARY IN THEIR DEPARTMENTS
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES E
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES R WHERE R.DEPARTMENT_ID = E.DEPARTMENT_ID);
       
----------------------------------------------
-- EXISTS / NOT EXISTS
-- EXISTS RETURNS TRUE if a subquery returns at least one row.

-- DISPLAY ALL DEPARTMENTS THAT HAVE EMPLOYEES
SELECT * FROM DEPARTMENTS D
WHERE EXISTS (SELECT 1 FROM EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID);

SELECT * FROM DEPARTMENTS D
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES E);
-- USING 'IN' IS NOT GOOD FOR PERFORMANCE

-- DISPLAY ALL DEPARTMENTS WITH NO EMPLOYEES
SELECT * FROM DEPARTMENTS D
WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID);

-- AS SHOWN EARLIER, WHEN THERE ARE NULL VALUES, NOT IN RETURNS 0 RECORDS
SELECT * FROM DEPARTMENTS D
WHERE DEPARTMENT_ID NOT IN (SELECT DEPARTMENT_ID FROM EMPLOYEES E);

-- IN/NOT IN SHOULD BE ELIMINATED FOR BETTER PERFORMANCE

----------------------------------------------
-- WITH CLAUSE
WITH EMP
AS
(
  SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES
)
SELECT FIRST_NAME
FROM EMP;

WITH EMP
AS
(
  SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY FROM EMPLOYEES
), DEPT_SUM_SAL
AS
(
  SELECT DEPARTMENT_ID, SUM(SALARY) SUM_SAL
  FROM EMP
  GROUP BY DEPARTMENT_ID
)
SELECT * FROM DEPT_SUM_SAL;

WITH DEPT_COUNT
AS
( 
  SELECT DEPARTMENT_ID, COUNT(1) CNT
  FROM EMPLOYEES
  GROUP BY DEPARTMENT_ID
)
SELECT DEPARTMENT_NAME, CNT
FROM DEPARTMENTS, DEPT_COUNT
WHERE DEPARTMENTS.DEPARTMENT_ID = DEPT_COUNT.DEPARTMENT_ID;

-- WRITE QUERY TO DISPLAY THE DEPARTMENT NAME AND TOTAL SALARIES FOR
-- THOSE DEPARTMENTS WHOSE TOTAL SALARIES ARE GREATER THAN AVG SALARY ACROSS ALL
-- DEPARTMENTS

SELECT DEPARTMENT_NAME, SUM(SALARY) SUM_SAL
FROM 
EMPLOYEES E JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME;

WITH DEPT_COSTS AS
(
  SELECT DEPARTMENT_NAME, SUM(SALARY) SUM_SAL
  FROM 
  EMPLOYEES E JOIN DEPARTMENTS D
  ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
  GROUP BY DEPARTMENT_NAME
), 
AVG_COST AS
(
  SELECT SUM(SUM_SAL)/COUNT(*) DEPT_AVG
  FROM DEPT_COSTS
)
SELECT * FROM DEPT_COSTS
WHERE SUM_SAL > (SELECT DEPT_AVG FROM AVG_COST);

----------------------------------------------
-- INSERTING/UPDATING/DELETING USING SUBQUERY AS TARGET
DESC DEPARTMENTS;

-- GENERATES A TEMPORARY VIEW TO INSERT RECORD
INSERT INTO
(
  SELECT DEPARTMENT_ID, DEPARTMENT_NAME
  FROM DEPARTMENTS
  WHERE DEPARTMENT_ID=10
)
VALUES (106, 'TEST D');

SELECT *
FROM DEPARTMENTS
WHERE DEPARTMENT_ID = 106;

-- CAN USE WITH CHECK OPTION
INSERT INTO
(
  SELECT DEPARTMENT_ID, DEPARTMENT_NAME
  FROM DEPARTMENTS
  WHERE DEPARTMENT_NAME LIKE 'TEST%'
  WITH CHECK OPTION
)
VALUES (107, 'OP');
-- ERROR - DEPARTMENT NAME HAS TO MATCH THE CHECK FORMAT
-- HAS ALL PROPERTIES OF VIEWS

INSERT INTO
(
  SELECT DEPARTMENT_ID, DEPARTMENT_NAME
  FROM DEPARTMENTS
  WHERE DEPARTMENT_NAME LIKE 'TEST%'
  WITH CHECK OPTION
)
VALUES (107, 'TEST D');
-- THIS WORKS

-- UPDATING SELECTING SUBQUERY AS TARGET
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20;

UPDATE
(
  SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM EMPLOYEES
  WHERE DEPARTMENT_ID = 20
)
SET SALARY = SALARY+100;
-- THOSE RECORDS UPDATED

-- DELETE USING SUBQUERY AS TARGET
DELETE
(
  SELECT * FROM DEPARTMENTS
  WHERE DEPARTMENT_ID = 106
);

----------------------------------------------
-- CORRELATED UPDATE
DROP TABLE EMP_COPY;

CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEES;

SELECT * FROM EMP_COPY;

UPDATE EMP_COPY
SET SALARY=0;

COMMIT;

-- FOR UPDATE ALIAS IS IMPORTANT
UPDATE EMP_COPY E_COPY
SET SALARY = (SELECT SALARY FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = E_COPY.EMPLOYEE_ID);
-- CORRELATED SINCE REFERENCING PARENT COLUMN

SELECT * FROM EMP_COPY;

-- ALERT: IF THERE IS A NON-MATCHING RECORD, THAT SALARY WILL BE SET TO NULL
-- SO MAKE SURE ONLY TO UPDATE FOR MATCHING RECORDS
UPDATE EMP_COPY E_COPY
SET SALARY = (SELECT SALARY FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = E_COPY.EMPLOYEE_ID)
WHERE EXISTS (SELECT 1 FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = E_COPY.EMPLOYEE_ID);

-- CORRELATED DELETE
DELETE FROM EMP_COPY
WHERE EXISTS (SELECT 1 FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = EMP_COPY.EMPLOYEE_ID);

SELECT * FROM EMP_COPY;